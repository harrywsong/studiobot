# cogs/casino_minesweeper.py - Updated for multi-server support with balanced odds
import discord
from discord.ext import commands
from discord import app_commands
import random
from typing import List, Tuple

from ipywidgets.widgets import interaction

from utils.logger import get_logger
from utils.config import (
    is_feature_enabled,
    get_server_setting
)


class MinesweeperView(discord.ui.View):
    """Interactive Minesweeper game with dropdown selection"""

    def __init__(self, bot, user_id: int, bet: int, mines: int, guild_id: int):
        super().__init__(timeout=300)  # 5 minutes timeout
        self.bot = bot
        self.user_id = user_id
        self.bet = bet
        self.mines_count = mines
        self.guild_id = guild_id
        self.game_over = False
        self.game_won = False
        self.revealed_gems = 0
        self.current_multiplier = 1.0

        # 5x5 grid
        self.grid_size = 5
        self.total_cells = self.grid_size * self.grid_size
        self.total_gems = self.total_cells - self.mines_count

        # Initialize grid (True = mine, False = gem)
        self.grid = self.generate_minefield()
        self.revealed = [[False for _ in range(self.grid_size)] for _ in range(self.grid_size)]

        # Selection state
        self.selected_position = None

        # Create UI components
        self.create_components()

    def generate_minefield(self) -> List[List[bool]]:
        """Generate minefield with specified number of mines"""
        # Create flat list with mines
        cells = [True] * self.mines_count + [False] * (self.total_cells - self.mines_count)
        random.shuffle(cells)

        # Convert to 2D grid
        grid = []
        for i in range(self.grid_size):
            row = []
            for j in range(self.grid_size):
                row.append(cells[i * self.grid_size + j])
            grid.append(row)

        return grid

    def create_components(self):
        """Create UI components for the game"""
        # Position selection dropdown
        self.position_select = PositionSelect()
        self.add_item(self.position_select)

        # Action buttons
        reveal_btn = discord.ui.Button(
            label="üîç ÏÑ†ÌÉùÌïú ÏúÑÏπò Í≥µÍ∞ú",
            style=discord.ButtonStyle.primary,
            custom_id="reveal"
        )
        reveal_btn.callback = self.reveal_callback
        self.add_item(reveal_btn)

        cash_out_btn = discord.ui.Button(
            label="üí∞ Ï∫êÏãúÏïÑÏõÉ",
            style=discord.ButtonStyle.success,
            custom_id="cash_out"
        )
        cash_out_btn.callback = self.cash_out_callback
        self.add_item(cash_out_btn)

    async def reveal_callback(self, interaction: discord.Interaction):
        """Handle reveal button"""
        if interaction.user.id != self.user_id or self.game_over:
            await interaction.response.send_message("‚ùå Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§!", ephemeral=True)
            return

        if self.selected_position is None:
            await interaction.response.send_message("‚ùå Î®ºÏ†Ä ÏúÑÏπòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî!", ephemeral=True)
            return

        row, col = self.selected_position
        if self.revealed[row][col]:
            await interaction.response.send_message("‚ùå Ïù¥ÎØ∏ Í≥µÍ∞úÎêú Ïπ∏ÏûÖÎãàÎã§!", ephemeral=True)
            return

        await interaction.response.defer()
        await self.reveal_cell(interaction, row, col)

    async def cash_out_callback(self, interaction: discord.Interaction):
        """Handle cash out button"""
        if interaction.user.id != self.user_id or self.game_over:
            await interaction.response.send_message("‚ùå Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§!", ephemeral=True)
            return

        if self.revealed_gems == 0:
            await interaction.response.send_message("‚ùå ÏµúÏÜå 1Í∞úÏùò Î≥¥ÏÑùÏùÑ Ï∞æÏïÑÏïº Ï∫êÏãúÏïÑÏõÉ Í∞ÄÎä•Ìï©ÎãàÎã§!", ephemeral=True)
            return

        await interaction.response.defer()
        await self.end_game(interaction, True)

    def calculate_multiplier(self) -> float:
        """Calculate current multiplier based on revealed gems and mine count - BALANCED VERSION"""
        if self.revealed_gems == 0:
            return 1.0

        # Get server-specific multiplier settings with much more conservative defaults
        base_multiplier = get_server_setting(self.guild_id, 'minesweeper_base_multiplier',
                                             0.95)  # Slightly less than 1x to account for house edge
        multiplier_per_gem = get_server_setting(self.guild_id, 'minesweeper_gem_multiplier',
                                                0.08)  # Reduced from 0.15 to 0.08
        mine_bonus = get_server_setting(self.guild_id, 'minesweeper_mine_bonus', 0.01)  # Reduced from 0.03 to 0.01

        # Calculate remaining gems and total revealed cells
        remaining_gems = self.total_gems - self.revealed_gems
        total_revealed = sum(sum(row) for row in self.revealed)
        remaining_cells = self.total_cells - total_revealed

        # Progressive multiplier with diminishing returns and risk consideration
        # The multiplier should reflect the actual probability of success
        if remaining_cells <= self.mines_count:
            # If only mines are left, this shouldn't happen, but handle it
            return base_multiplier + (self.revealed_gems * multiplier_per_gem * (1 + self.mines_count * mine_bonus))

        # Calculate risk factor: probability of hitting a mine on next reveal
        mine_risk_factor = self.mines_count / remaining_cells if remaining_cells > 0 else 1.0

        # Multiplier increases with each gem found, but with diminishing returns
        # Higher mine counts give slightly better multipliers, but not excessively
        multiplier = base_multiplier + (
                self.revealed_gems * multiplier_per_gem *
                (1 + (self.mines_count * mine_bonus)) *
                (1.0 + mine_risk_factor * 0.1)  # Small risk bonus
        )

        # Cap the multiplier to prevent excessive payouts
        max_multiplier = get_server_setting(self.guild_id, 'minesweeper_max_multiplier', 3.0)
        return min(multiplier, max_multiplier)

    async def reveal_cell(self, interaction: discord.Interaction, row: int, col: int):
        """Reveal a cell and handle game logic"""
        self.revealed[row][col] = True

        if self.grid[row][col]:  # Hit a mine
            await self.end_game(interaction, False)
        else:  # Found a gem
            self.revealed_gems += 1
            self.current_multiplier = self.calculate_multiplier()

            # Reset selection
            self.selected_position = None
            self.position_select.placeholder = "ÏúÑÏπòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî (Ïòà: A1, B3, C5)"

            # Check if won (found all gems)
            if self.revealed_gems >= self.total_gems:
                await self.end_game(interaction, True)
            else:
                embed = await self.create_game_embed()
                await interaction.edit_original_response(embed=embed, view=self)

    def format_grid(self) -> str:
        """Format the grid for display"""
        grid_lines = []
        grid_lines.append("```")
        grid_lines.append("    1  2  3  4  5")

        for i, letter in enumerate(['A', 'B', 'C', 'D', 'E']):
            line = f"{letter}:"
            for j in range(self.grid_size):
                if self.revealed[i][j]:
                    if self.grid[i][j]:  # Mine
                        line += " üí£"
                    else:  # Gem
                        line += " üíé"
                else:  # Hidden
                    line += " ‚¨õ"
            grid_lines.append(line)

        grid_lines.append("```")
        return "\n".join(grid_lines)

    async def create_game_embed(self, game_ended: bool = False, won: bool = False) -> discord.Embed:
        """Create the game status embed"""
        if game_ended:
            if won:
                title = "üíé ÏäπÎ¶¨! ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∫êÏãúÏïÑÏõÉ!"
                color = discord.Color.green()
                payout = int(self.bet * self.current_multiplier)
                profit = payout - self.bet
                description = f"üéØ **Î∞úÍ≤¨Ìïú Î≥¥ÏÑù:** {self.revealed_gems}/{self.total_gems}Í∞ú\nüìà **ÏµúÏ¢Ö Î∞∞Ïàò:** {self.current_multiplier:.2f}x\nüí∞ **Ï¥ù ÌöçÎìù:** {payout:,}ÏΩîÏù∏ (ÏàúÏùµ: +{profit:,})"
            else:
                title = "üí£ Ìè≠Î∞ú! ÏßÄÎ¢∞Î•º Î∞üÏïòÏäµÎãàÎã§!"
                color = discord.Color.red()
                description = f"üéØ **Î∞úÍ≤¨Ìïú Î≥¥ÏÑù:** {self.revealed_gems}/{self.total_gems}Í∞ú\nüìâ **ÎèÑÎã¨ Î∞∞Ïàò:** {self.current_multiplier:.2f}x\nüí∏ **ÏÜêÏã§:** -{self.bet:,}ÏΩîÏù∏"
        else:
            title = "üí£ ÏßÄÎ¢∞Ï∞æÍ∏∞"
            color = discord.Color.blue()
            remaining_gems = self.total_gems - self.revealed_gems
            potential_payout = int(self.bet * self.current_multiplier)
            potential_profit = potential_payout - self.bet

            description = f"üí£ **ÏßÄÎ¢∞:** {self.mines_count}Í∞ú | üíé **ÎÇ®ÏùÄ Î≥¥ÏÑù:** {remaining_gems}Í∞ú\n"
            description += f"üéØ **Î∞úÍ≤¨Ìïú Î≥¥ÏÑù:** {self.revealed_gems}Í∞ú\n"
            description += f"üìà **ÌòÑÏû¨ Î∞∞Ïàò:** {self.current_multiplier:.2f}x\n"
            description += f"üí∞ **ÌòÑÏû¨ Ï∫êÏãúÏïÑÏõÉ:** {potential_payout:,}ÏΩîÏù∏"

            if potential_profit > 0:
                description += f" (ÏàúÏùµ: +{potential_profit:,})"
            elif potential_profit < 0:
                description += f" (ÏÜêÏã§: {potential_profit:,})"

            if self.selected_position:
                row, col = self.selected_position
                pos_name = f"{['A', 'B', 'C', 'D', 'E'][row]}{col + 1}"
                description += f"\n\nüìç **ÏÑ†ÌÉùÎêú ÏúÑÏπò:** {pos_name}"

        embed = discord.Embed(title=title, description=description, color=color)

        # Add the game grid
        embed.add_field(name="üéÆ Í≤åÏûÑ Î≥¥Îìú", value=self.format_grid(), inline=False)

        if not game_ended:
            embed.add_field(
                name="üìã Í≤åÏûÑ Î∞©Î≤ï",
                value="1Ô∏è‚É£ ÎìúÎ°≠Îã§Ïö¥ÏóêÏÑú ÏúÑÏπò ÏÑ†ÌÉù (A1~E5)\n2Ô∏è‚É£ 'üîç ÏÑ†ÌÉùÌïú ÏúÑÏπò Í≥µÍ∞ú' ÌÅ¥Î¶≠\n3Ô∏è‚É£ üíé Î≥¥ÏÑùÏùÑ Ï∞æÏúºÎ©¥ Í≥ÑÏÜç, üí£ ÏßÄÎ¢∞Î•º Î∞üÏúºÎ©¥ Í≤åÏûÑ Ï¢ÖÎ£å\n4Ô∏è‚É£ üí∞ Ïñ∏Ï†úÎì†ÏßÄ Ï∫êÏãúÏïÑÏõÉ Í∞ÄÎä•",
                inline=False
            )

            # Calculate next reveal statistics
            total_revealed = sum(sum(row) for row in self.revealed)
            remaining_cells = self.total_cells - total_revealed

            if remaining_cells > 0 and remaining_gems > 0:
                # Calculate probability and next multiplier
                success_rate = (remaining_gems / remaining_cells) * 100

                # Simulate next multiplier
                temp_gems = self.revealed_gems + 1
                base_multiplier = get_server_setting(self.guild_id, 'minesweeper_base_multiplier', 0.95)
                multiplier_per_gem = get_server_setting(self.guild_id, 'minesweeper_gem_multiplier', 0.08)
                mine_bonus = get_server_setting(self.guild_id, 'minesweeper_mine_bonus', 0.01)

                next_remaining_cells = remaining_cells - 1
                next_mine_risk = self.mines_count / next_remaining_cells if next_remaining_cells > 0 else 1.0

                next_multiplier = base_multiplier + (
                        temp_gems * multiplier_per_gem *
                        (1 + (self.mines_count * mine_bonus)) *
                        (1.0 + next_mine_risk * 0.1)
                )
                max_multiplier = get_server_setting(self.guild_id, 'minesweeper_max_multiplier', 3.0)
                next_multiplier = min(next_multiplier, max_multiplier)

                next_payout = int(self.bet * next_multiplier)
                next_profit = next_payout - self.bet

                embed.add_field(
                    name="üìä ÏúÑÌóòÎèÑ Î∂ÑÏÑù",
                    value=f"üéØ **Îã§Ïùå Î≥¥ÏÑù Î∞úÍ≤¨Ïãú:** {next_multiplier:.2f}x ({next_payout:,}ÏΩîÏù∏, ÏàúÏùµ: +{next_profit:,})\n‚ö° **ÏÑ±Í≥µ ÌôïÎ•†:** {success_rate:.1f}%\nüí£ **ÏßÄÎ¢∞ ÌôïÎ•†:** {100 - success_rate:.1f}%",
                    inline=False
                )

        embed.set_footer(
            text=f"Server: {interaction.guild.name if hasattr(self, '_interaction') and self._interaction.guild else 'Unknown'}")
        return embed

    async def end_game(self, interaction: discord.Interaction, won: bool):
        """End the game and calculate payouts"""
        self.game_over = True
        self.game_won = won

        # Reveal all cells
        for i in range(self.grid_size):
            for j in range(self.grid_size):
                self.revealed[i][j] = True

        # Disable all components
        for item in self.children:
            item.disabled = True

        # Handle payout
        coins_cog = self.bot.get_cog('CoinsCog')
        if coins_cog and won:
            payout = int(self.bet * self.current_multiplier)
            await coins_cog.add_coins(
                self.user_id,
                interaction.guild.id,
                payout,
                "minesweeper_win",
                f"ÏßÄÎ¢∞Ï∞æÍ∏∞ ÏäπÎ¶¨: {self.revealed_gems}Í∞ú Î≥¥ÏÑù, {self.current_multiplier:.2f}x Î∞∞Ïàò"
            )

        embed = await self.create_game_embed(True, won)

        if coins_cog:
            new_balance = await coins_cog.get_user_coins(self.user_id, interaction.guild.id)
            embed.add_field(name="üí≥ ÌòÑÏû¨ ÏûîÏï°", value=f"{new_balance:,} ÏΩîÏù∏", inline=True)

        await interaction.edit_original_response(embed=embed, view=self)


class PositionSelect(discord.ui.Select):
    """Dropdown for selecting grid positions"""

    def __init__(self):
        options = []

        # Create options for each grid position
        for i, letter in enumerate(['A', 'B', 'C', 'D', 'E']):
            for j in range(1, 6):
                options.append(discord.SelectOption(
                    label=f"{letter}{j}",
                    description=f"{letter}Ìñâ {j}Ïó¥",
                    value=f"{i},{j - 1}",
                    emoji="üìç"
                ))

        super().__init__(
            placeholder="ÏúÑÏπòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî (Ïòà: A1, B3, C5)",
            options=options,
            custom_id="position_select"
        )

    async def callback(self, interaction: discord.Interaction):
        view: MinesweeperView = self.view
        if interaction.user.id != view.user_id or view.game_over:
            await interaction.response.send_message("‚ùå Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§!", ephemeral=True)
            return

        # Parse selected position
        row, col = map(int, self.values[0].split(','))

        if view.revealed[row][col]:
            await interaction.response.send_message("‚ùå Ïù¥ÎØ∏ Í≥µÍ∞úÎêú Ïπ∏ÏûÖÎãàÎã§!", ephemeral=True)
            return

        # Update selection
        view.selected_position = (row, col)
        position_name = f"{['A', 'B', 'C', 'D', 'E'][row]}{col + 1}"
        self.placeholder = f"ÏÑ†ÌÉùÎê®: {position_name}"

        embed = await view.create_game_embed()
        await interaction.response.edit_message(embed=embed, view=view)


class MinesweeperCog(commands.Cog):
    """Casino Minesweeper game - Multi-server aware"""

    def __init__(self, bot):
        self.bot = bot
        # FIX: The logger is now a global singleton, so we just get it by name.
        self.logger = get_logger("ÏßÄÎ¢∞Ï∞æÍ∏∞")
        self.logger.info("ÏßÄÎ¢∞Ï∞æÍ∏∞ Í≤åÏûÑ ÏãúÏä§ÌÖúÏù¥ Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.")

    async def validate_game(self, interaction: discord.Interaction, bet: int):
        """Validate game using casino base"""
        casino_base = self.bot.get_cog('CasinoBaseCog')
        if not casino_base:
            return False, "Ïπ¥ÏßÄÎÖ∏ ÏãúÏä§ÌÖúÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§!"

        # Get server-specific limits
        min_bet = get_server_setting(interaction.guild.id, 'minesweeper_min_bet', 10)
        max_bet = get_server_setting(interaction.guild.id, 'minesweeper_max_bet',
                                     500)  # Increased max bet since payouts are now balanced

        return await casino_base.validate_game_start(
            interaction, "minesweeper", bet, min_bet, max_bet
        )

    @app_commands.command(name="ÏßÄÎ¢∞Ï∞æÍ∏∞", description="ÏßÄÎ¢∞Î•º ÌîºÌï¥ Î≥¥ÏÑùÏùÑ Ï∞æÎäî Í≤åÏûÑ")
    @app_commands.describe(
        bet="Î≤†ÌåÖ Í∏àÏï°",
        mines="ÏßÄÎ¢∞ Í∞úÏàò (1-12, ÎßéÏùÑÏàòÎ°ù ÏúÑÌóòÌïòÏßÄÎßå ÎÜíÏùÄ ÏàòÏùµ)"
    )
    async def minesweeper(self, interaction: discord.Interaction, bet: int,
                          mines: int = 4):  # Changed default from 3 to 5
        # Check if casino games are enabled for this server
        if not interaction.guild or not is_feature_enabled(interaction.guild.id, 'casino_games'):
            await interaction.response.send_message("‚ùå Ïù¥ ÏÑúÎ≤ÑÏóêÏÑúÎäî Ïπ¥ÏßÄÎÖ∏ Í≤åÏûÑÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§!", ephemeral=True)
            return

        # Get server-specific mine limits - reduced max mines since higher mine counts were too profitable
        max_mines = get_server_setting(interaction.guild.id, 'minesweeper_max_mines', 12)

        if not (4 <= mines <= max_mines):
            await interaction.response.send_message(f"‚ùå ÏßÄÎ¢∞Îäî 4-{max_mines}Í∞ú ÏÇ¨Ïù¥Îßå ÏÑ§Ï†ï Í∞ÄÎä•Ìï©ÎãàÎã§!", ephemeral=True)
            return

        if mines >= 24:  # Max 24 mines in 5x5 grid (need at least 1 gem)
            await interaction.response.send_message("‚ùå 5x5 Î≥¥ÎìúÏóêÏÑúÎäî ÏµúÎåÄ 12Í∞úÏùò ÏßÄÎ¢∞Îßå ÏÑ§Ï†ï Í∞ÄÎä•Ìï©ÎãàÎã§!", ephemeral=True)
            return

        can_start, error_msg = await self.validate_game(interaction, bet)
        if not can_start:
            await interaction.response.send_message(error_msg, ephemeral=True)
            return

        coins_cog = self.bot.get_cog('CoinsCog')
        if not await coins_cog.remove_coins(interaction.user.id, interaction.guild.id, bet, "minesweeper_bet",
                                            "ÏßÄÎ¢∞Ï∞æÍ∏∞ Î≤†ÌåÖ"):
            await interaction.response.send_message("‚ùå Î≤†ÌåÖ Ï≤òÎ¶¨ Ïã§Ìå®!", ephemeral=True)
            return

        # Create game view
        view = MinesweeperView(self.bot, interaction.user.id, bet, mines, interaction.guild.id)
        embed = await view.create_game_embed()

        await interaction.response.send_message(embed=embed, view=view)
        # FIX: Add extra={'guild_id': ...} for multi-server logging context
        self.logger.info(
            f"{interaction.user}Í∞Ä {bet}ÏΩîÏù∏, {mines}Í∞ú ÏßÄÎ¢∞Î°ú ÏßÄÎ¢∞Ï∞æÍ∏∞ ÏãúÏûë",
            extra={'guild_id': interaction.guild.id}
        )


async def setup(bot):
    await bot.add_cog(MinesweeperCog(bot))