# cogs/coins.py
from typing import Optional

import discord
from discord.ext import commands, tasks
from discord import app_commands
import asyncio
import traceback
import json
import os
from datetime import datetime, timezone, timedelta
import pytz

from utils.logger import get_logger
from utils import config


class CoinsView(discord.ui.View):
    """Persistent view for claiming daily coins"""

    def __init__(self, bot):
        super().__init__(timeout=None)
        self.bot = bot
        # FIX: Initialize logger here for guild-specific logging if needed in view methods
        self.logger = get_logger("ÏΩîÏù∏ ÏãúÏä§ÌÖú")


    @discord.ui.button(label="üí∞ ÏùºÏùº ÏΩîÏù∏ Î∞õÍ∏∞", style=discord.ButtonStyle.green, custom_id="claim_daily_coins")
    async def claim_daily_coins(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Check if casino games are enabled for this server
        if not config.is_feature_enabled(interaction.guild.id, 'casino_games'):
            await interaction.response.send_message(
                "‚ùå Ïù¥ ÏÑúÎ≤ÑÏóêÏÑúÎäî ÏΩîÏù∏ ÏãúÏä§ÌÖúÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.",
                ephemeral=True
            )
            return

        await interaction.response.defer(ephemeral=True)

        user_id = interaction.user.id
        guild_id = interaction.guild.id
        eastern = pytz.timezone('America/New_York')
        now = datetime.now(eastern)  # This is timezone-aware
        today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)  # Still timezone-aware

        try:
            # Check if user already claimed today (guild-specific)
            check_query = """
                    SELECT last_claim_date FROM user_coins 
                    WHERE user_id = $1 AND guild_id = $2
                """
            row = await self.bot.pool.fetchrow(check_query, user_id, guild_id)

            if row and row['last_claim_date']:
                # The database returns a naive datetime, so we need to make it timezone-aware
                last_claim = row['last_claim_date']

                # If last_claim is naive, assume it's in EST and make it timezone-aware
                if last_claim.tzinfo is None:
                    last_claim = eastern.localize(last_claim)
                else:
                    # If it already has timezone info, convert to eastern
                    last_claim = last_claim.astimezone(eastern)

                if last_claim >= today_start:
                    next_claim = (today_start + timedelta(days=1)).strftime("%Y-%m-%d %H:%M:%S EST")
                    await interaction.followup.send(
                        f"‚ùå Ïò§ÎäòÏùÄ Ïù¥ÎØ∏ ÏΩîÏù∏ÏùÑ Î∞õÏïòÏäµÎãàÎã§!\nÎã§Ïùå Î∞õÍ∏∞: {next_claim}",
                        ephemeral=True
                    )
                    return

            # Get starting coins amount from server settings
            starting_coins = config.get_server_setting(guild_id, 'starting_coins', 50)

            # Give daily coins using the add_coins method to trigger leaderboard update
            coins_cog = self.bot.get_cog('CoinsCog')
            if coins_cog:
                # Store as naive datetime in the database (convert timezone-aware to naive)
                naive_now = now.replace(tzinfo=None)

                # Update the database directly for daily claims to include last_claim_date
                update_query = """
                        INSERT INTO user_coins (user_id, guild_id, coins, last_claim_date, total_earned)
                        VALUES ($1, $2, $3, $4, $3)
                        ON CONFLICT (user_id, guild_id) 
                        DO UPDATE SET 
                            coins = user_coins.coins + $3,
                            total_earned = user_coins.total_earned + $3,
                            last_claim_date = EXCLUDED.last_claim_date
                        RETURNING coins
                    """
                result = await self.bot.pool.fetchrow(update_query, user_id, guild_id, starting_coins, naive_now)

                # Log transaction
                await self.bot.pool.execute("""
                        INSERT INTO coin_transactions (user_id, guild_id, amount, transaction_type, description)
                        VALUES ($1, $2, $3, $4, $5)
                    """, user_id, guild_id, starting_coins, "daily_claim", "Daily coin claim")

                # Trigger leaderboard update
                self.bot.loop.create_task(coins_cog.schedule_leaderboard_update(guild_id))

                embed = discord.Embed(
                    title="üí∞ ÏùºÏùº ÏΩîÏù∏ ÏßÄÍ∏â!",
                    description=f"‚úÖ {starting_coins} ÏΩîÏù∏ÏùÑ Î∞õÏïòÏäµÎãàÎã§!\nÌòÑÏû¨ ÏûîÏï°: **{result['coins']} ÏΩîÏù∏**",
                    color=discord.Color.gold(),
                    timestamp=datetime.now(timezone.utc)
                )
                embed.set_footer(text="Îã§Ïùå Î∞õÍ∏∞Îäî ÎÇ¥Ïùº ÏûêÏ†ï(EST)Ïóê Í∞ÄÎä•Ìï©ÎãàÎã§")

                await interaction.followup.send(embed=embed, ephemeral=True)

        except Exception as e:
            await interaction.followup.send(f"‚ùå Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {e}", ephemeral=True)
            # FIX: Add guild_id to log message
            self.logger.error(f"Daily coin claim error for {user_id} in guild {guild_id}: {e}", extra={'guild_id': guild_id})


class LeaderboardView(discord.ui.View):
    """Persistent view for coin leaderboard navigation"""

    def __init__(self, bot, guild_id=None):
        super().__init__(timeout=None)
        self.bot = bot
        self.guild_id = guild_id
        self.current_page = 0
        self.users_per_page = 10
        # FIX: Initialize logger here
        self.logger = get_logger("ÏΩîÏù∏ ÏãúÏä§ÌÖú")


    async def get_leaderboard_data(self):
        """Get leaderboard data from database for this guild"""
        query = """
            SELECT user_id, coins 
            FROM user_coins 
            WHERE coins > 0 AND guild_id = $1
            ORDER BY coins DESC 
            LIMIT 100
        """
        return await self.bot.pool.fetch(query, self.guild_id)

    async def create_leaderboard_embed(self, page=0):
        """Create leaderboard embed for specific page"""
        data = await self.get_leaderboard_data()

        if not data:
            embed = discord.Embed(
                title="üèÜ ÏΩîÏù∏ Î¶¨ÎçîÎ≥¥Îìú",
                description="ÏïÑÏßÅ ÏΩîÏù∏ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.",
                color=discord.Color.gold()
            )
            return embed

        total_pages = (len(data) - 1) // self.users_per_page + 1
        page = max(0, min(page, total_pages - 1))

        start_idx = page * self.users_per_page
        end_idx = start_idx + self.users_per_page
        page_data = data[start_idx:end_idx]

        embed = discord.Embed(
            title="üèÜ ÏΩîÏù∏ Î¶¨ÎçîÎ≥¥Îìú",
            color=discord.Color.gold(),
            timestamp=datetime.now(timezone.utc)
        )

        leaderboard_text = ""
        for idx, record in enumerate(page_data, start=start_idx + 1):
            try:
                user = self.bot.get_user(record['user_id'])
                username = user.display_name if user else f"Unknown User ({record['user_id']})"

                # Add medal emojis for top 3
                if idx == 1:
                    medal = "ü•á"
                elif idx == 2:
                    medal = "ü•à"
                elif idx == 3:
                    medal = "ü•â"
                else:
                    medal = f"`{idx:2d}.`"

                leaderboard_text += f"{medal} **{username}** - {record['coins']:,} ÏΩîÏù∏\n"
            except:
                # FIX: Add guild_id to log message
                self.logger.warning(f"Could not fetch user for leaderboard entry: User ID {record['user_id']}, Guild ID {self.guild_id}", extra={'guild_id': self.guild_id})
                leaderboard_text += f"`{idx:2d}.` Unknown User - {record['coins']:,} ÏΩîÏù∏\n"

        embed.description = leaderboard_text or "Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§."
        embed.set_footer(text=f"ÌéòÏù¥ÏßÄ {page + 1}/{total_pages} ‚Ä¢ Ï¥ù {len(data)}Î™Ö")

        return embed

    @discord.ui.button(label="‚¨ÖÔ∏è", style=discord.ButtonStyle.secondary, custom_id="leaderboard_prev")
    async def previous_page(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()

        # Get guild_id from interaction if not set
        if not self.guild_id:
            self.guild_id = interaction.guild.id

        if self.current_page > 0:
            self.current_page -= 1
            embed = await self.create_leaderboard_embed(self.current_page)
            await interaction.edit_original_response(embed=embed, view=self)

    @discord.ui.button(label="‚û°Ô∏è", style=discord.ButtonStyle.secondary, custom_id="leaderboard_next")
    async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()

        # Get guild_id from interaction if not set
        if not self.guild_id:
            self.guild_id = interaction.guild.id

        data = await self.get_leaderboard_data()
        total_pages = (len(data) - 1) // self.users_per_page + 1 if data else 1

        if self.current_page < total_pages - 1:
            self.current_page += 1
            embed = await self.create_leaderboard_embed(self.current_page)
            await interaction.edit_original_response(embed=embed, view=self)


class CoinsCog(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        # FIX: Logger initialization updated
        self.logger = get_logger("ÏΩîÏù∏ ÏãúÏä§ÌÖú")

        # Spam protection - user_id: last_command_time
        self.last_command_time = {}
        self.cooldown_seconds = 3

        # Per-guild leaderboard management
        self.guild_leaderboard_data = {}  # guild_id: message_info
        self.guild_claim_data = {}  # guild_id: message_info

        # Real-time update controls per guild
        self.pending_leaderboard_updates = {}  # guild_id: bool
        self.update_delay = 3  # seconds to debounce updates
        self.last_leaderboard_cache = {}  # guild_id: data

        # Message ID persistence per guild
        self.message_ids_file = "data/guild_message_ids.json"

        self.logger.info("ÏΩîÏù∏ ÏãúÏä§ÌÖúÏù¥ Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.")

        # Start tasks after bot is ready
        self.bot.loop.create_task(self.wait_and_start_tasks())

    def has_admin_permissions(self, member: discord.Member) -> bool:
        """Check if member has admin permissions"""
        # Check if user has administrator permissions
        if member.guild_permissions.administrator:
            return True

        # Check if user has the specific admin role for this guild
        admin_role_id = config.get_role_id(member.guild.id, 'admin_role')
        if admin_role_id:
            admin_role = discord.utils.get(member.roles, id=admin_role_id)
            return admin_role is not None

        # Fallback to staff role if admin role not configured
        staff_role_id = config.get_role_id(member.guild.id, 'staff_role')
        if staff_role_id:
            staff_role = discord.utils.get(member.roles, id=staff_role_id)
            return staff_role is not None

        return False

    async def wait_and_start_tasks(self):
        """Wait for bot to be ready then start tasks"""
        await self.bot.wait_until_ready()
        await self.setup_database()
        await self.load_message_ids()

        # Setup initial leaderboards for all configured guilds
        all_configs = config.get_all_server_configs()
        for guild_id_str, guild_config in all_configs.items():
            if guild_config.get('features', {}).get('casino_games'):
                guild_id = int(guild_id_str)
                await self.setup_initial_leaderboard(guild_id)

        # Start maintenance task
        self.maintenance_leaderboard_update.start()

    async def load_message_ids(self):
        """Load persistent message IDs from file"""
        try:
            if os.path.exists(self.message_ids_file):
                with open(self.message_ids_file, 'r') as f:
                    data = json.load(f)
                    self.guild_leaderboard_data = data.get('leaderboard', {})
                    self.guild_claim_data = data.get('claim', {})
                    # FIX: Add guild_id to log message (although this is global, context is useful)
                    self.logger.info("Loaded guild message IDs", extra={'guild_id': None}) # Using None as no specific guild context
        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error loading message IDs: {e}", extra={'guild_id': None})

    async def save_message_ids(self):
        """Save message IDs to file for persistence"""
        try:
            os.makedirs(os.path.dirname(self.message_ids_file), exist_ok=True)

            data = {
                'leaderboard': self.guild_leaderboard_data,
                'claim': self.guild_claim_data
            }

            with open(self.message_ids_file, 'w') as f:
                json.dump(data, f)
        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error saving message IDs: {e}", extra={'guild_id': None})

    async def setup_initial_leaderboard(self, guild_id: int):
        """Setup initial leaderboard and claim messages for a specific guild"""
        try:
            # Get leaderboard channel for this guild
            leaderboard_channel_id = config.get_channel_id(guild_id, 'leaderboard_channel')
            if not leaderboard_channel_id:
                # FIX: Add guild_id to log message
                self.logger.warning(f"No leaderboard channel configured for guild {guild_id}", extra={'guild_id': guild_id})
                return

            channel = self.bot.get_channel(leaderboard_channel_id)
            if not channel:
                # FIX: Add guild_id to log message
                self.logger.error(f"Leaderboard channel {leaderboard_channel_id} not found for guild {guild_id}", extra={'guild_id': guild_id})
                return

            guild_str = str(guild_id)

            # Verify existing message IDs are still valid
            if guild_str in self.guild_leaderboard_data:
                message_id = self.guild_leaderboard_data[guild_str]
                try:
                    await channel.fetch_message(message_id)
                    # FIX: Add guild_id to log message
                    self.logger.info(f"Found existing leaderboard message {message_id} for guild {guild_id}", extra={'guild_id': guild_id})
                except discord.NotFound:
                    # FIX: Add guild_id to log message
                    self.logger.warning(
                        f"Stored leaderboard message {message_id} no longer exists for guild {guild_id}", extra={'guild_id': guild_id})
                    del self.guild_leaderboard_data[guild_str]

            if guild_str in self.guild_claim_data:
                message_id = self.guild_claim_data[guild_str]
                try:
                    await channel.fetch_message(message_id)
                    # FIX: Add guild_id to log message
                    self.logger.info(f"Found existing claim message {message_id} for guild {guild_id}", extra={'guild_id': guild_id})
                except discord.NotFound:
                    # FIX: Add guild_id to log message
                    self.logger.warning(f"Stored claim message {message_id} no longer exists for guild {guild_id}", extra={'guild_id': guild_id})
                    del self.guild_claim_data[guild_str]

            # Update leaderboard (will find existing message if ID is None)
            await self.update_leaderboard_now(guild_id)

            # Setup claim message if needed
            if guild_str not in self.guild_claim_data:
                # Try to find existing claim message first
                found_claim = False
                async for msg in channel.history(limit=50):
                    if (msg.author == self.bot.user and
                            msg.embeds and
                            msg.embeds[0].title and
                            "ÏùºÏùº ÏΩîÏù∏" in msg.embeds[0].title):
                        self.guild_claim_data[guild_str] = msg.id
                        await self.save_message_ids()
                        # Ensure the view is attached
                        await msg.edit(view=CoinsView(self.bot))
                        found_claim = True
                        # FIX: Add guild_id to log message
                        self.logger.info(f"Found and updated existing claim message {msg.id} for guild {guild_id}", extra={'guild_id': guild_id})
                        break

                # Create new claim message only if none found
                if not found_claim:
                    embed = discord.Embed(
                        title="üí∞ ÏùºÏùº ÏΩîÏù∏",
                        description="Îß§Ïùº ÏûêÏ†ï(EST)Ïóê Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§.\nÏïÑÎûò Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ ÏùºÏùº ÏΩîÏù∏ÏùÑ Î∞õÏúºÏÑ∏Ïöî!",
                        color=discord.Color.green()
                    )
                    message = await channel.send(embed=embed, view=CoinsView(self.bot))
                    self.guild_claim_data[guild_str] = message.id
                    await self.save_message_ids()
                    # FIX: Add guild_id to log message
                    self.logger.info(f"Created new claim message {message.id} for guild {guild_id}", extra={'guild_id': guild_id})

            # FIX: Add guild_id to log message
            self.logger.info(f"Initial leaderboard setup completed for guild {guild_id}", extra={'guild_id': guild_id})
        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error in initial leaderboard setup for guild {guild_id}: {e}", extra={'guild_id': guild_id})

    async def schedule_leaderboard_update(self, guild_id: int):
        """Schedule a delayed leaderboard update to debounce multiple changes"""
        if self.pending_leaderboard_updates.get(guild_id, False):
            return

        self.pending_leaderboard_updates[guild_id] = True

        # Wait for debounce period
        await asyncio.sleep(self.update_delay)

        try:
            await self.update_leaderboard_now(guild_id)
        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error in scheduled leaderboard update for guild {guild_id}: {e}", extra={'guild_id': guild_id})
        finally:
            self.pending_leaderboard_updates[guild_id] = False

    async def should_update_leaderboard(self, guild_id: int) -> bool:
        """Check if leaderboard actually needs updating by comparing data"""
        try:
            # Get current top 10 for comparison
            query = """
                SELECT user_id, coins 
                FROM user_coins 
                WHERE coins > 0 AND guild_id = $1
                ORDER BY coins DESC 
                LIMIT 10
            """
            current_data = await self.bot.pool.fetch(query, guild_id)

            # Convert to comparable format
            current_top = [(record['user_id'], record['coins']) for record in current_data]

            # Compare with cached data
            if self.last_leaderboard_cache.get(guild_id) == current_top:
                return False

            self.last_leaderboard_cache[guild_id] = current_top
            return True

        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error checking leaderboard changes for guild {guild_id}: {e}", extra={'guild_id': guild_id})
            return True  # Update on error to be safe

    async def update_leaderboard_now(self, guild_id: int):
        """Update leaderboard immediately using only message edits for specific guild"""
        # Get leaderboard channel for this guild
        leaderboard_channel_id = config.get_channel_id(guild_id, 'leaderboard_channel')
        if not leaderboard_channel_id:
            return

        # Check if update is actually needed
        if not await self.should_update_leaderboard(guild_id):
            return

        try:
            channel = self.bot.get_channel(leaderboard_channel_id)
            if not channel:
                # FIX: Add guild_id to log message
                self.logger.error(f"Leaderboard channel {leaderboard_channel_id} not found for guild {guild_id} during update.", extra={'guild_id': guild_id})
                return

            # Create new leaderboard
            leaderboard_view = LeaderboardView(self.bot, guild_id)
            leaderboard_embed = await leaderboard_view.create_leaderboard_embed()

            guild_str = str(guild_id)

            # Try to edit existing message first
            if guild_str in self.guild_leaderboard_data:
                try:
                    message_id = self.guild_leaderboard_data[guild_str]
                    message = await channel.fetch_message(message_id)
                    await message.edit(embed=leaderboard_embed, view=leaderboard_view)
                    # FIX: Add guild_id to log message
                    self.logger.info(f"Leaderboard updated via edit for guild {guild_id}", extra={'guild_id': guild_id})
                    return  # Successfully edited, exit early
                except discord.NotFound:
                    # FIX: Add guild_id to log message
                    self.logger.warning(
                        f"Leaderboard message {message_id} not found for guild {guild_id}, will search for existing message", extra={'guild_id': guild_id})
                    del self.guild_leaderboard_data[guild_str]  # Reset to search for existing
                except discord.HTTPException as e:
                    # Handle rate limits gracefully
                    if e.status == 429:
                        # FIX: Add guild_id to log message
                        self.logger.warning(f"Rate limited while updating leaderboard for guild {guild_id}", extra={'guild_id': guild_id})
                        return  # Skip this update due to rate limit
                    else:
                        # FIX: Add guild_id to log message
                        self.logger.error(f"HTTP error updating leaderboard for guild {guild_id}: {e}", extra={'guild_id': guild_id})
                        return

            # If no stored message ID, try to find existing leaderboard message
            async for msg in channel.history(limit=50):
                if (msg.author == self.bot.user and
                        msg.embeds and
                        msg.embeds[0].title and
                        "Î¶¨ÎçîÎ≥¥Îìú" in msg.embeds[0].title):
                    try:
                        await msg.edit(embed=leaderboard_embed, view=leaderboard_view)
                        self.guild_leaderboard_data[guild_str] = msg.id  # Store the found message ID
                        await self.save_message_ids()  # Persist the ID
                        # FIX: Add guild_id to log message
                        self.logger.info(
                            f"Found and updated existing leaderboard message {msg.id} for guild {guild_id}", extra={'guild_id': guild_id})
                        return
                    except discord.HTTPException:
                        continue  # Try next message if this one fails

            # Only create new message if we absolutely cannot find or edit an existing one
            message = await channel.send(embed=leaderboard_embed, view=leaderboard_view)
            self.guild_leaderboard_data[guild_str] = message.id
            await self.save_message_ids()  # Persist the new ID
            # FIX: Add guild_id to log message
            self.logger.info(
                f"Created new leaderboard message {message.id} for guild {guild_id} (no existing message found)", extra={'guild_id': guild_id})

        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error updating leaderboard for guild {guild_id}: {e}", extra={'guild_id': guild_id})

    async def setup_database(self):
        """Create necessary database tables with indexes for better performance"""
        try:
            await self.bot.pool.execute("""
                CREATE TABLE IF NOT EXISTS user_coins (
                    user_id BIGINT NOT NULL,
                    guild_id BIGINT NOT NULL,
                    coins INTEGER DEFAULT 0,
                    last_claim_date TIMESTAMP,
                    total_earned INTEGER DEFAULT 0,
                    total_spent INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (user_id, guild_id)
                )
            """)

            await self.bot.pool.execute("""
                CREATE TABLE IF NOT EXISTS coin_transactions (
                    id SERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    guild_id BIGINT NOT NULL,
                    amount INTEGER NOT NULL,
                    transaction_type VARCHAR(50) NOT NULL,
                    description TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # Create indexes for better performance
            await self.bot.pool.execute("""
                CREATE INDEX IF NOT EXISTS idx_user_coins_guild_coins ON user_coins(guild_id, coins DESC);
            """)

            await self.bot.pool.execute("""
                CREATE INDEX IF NOT EXISTS idx_coin_transactions_user_guild ON coin_transactions(user_id, guild_id);
            """)

            await self.bot.pool.execute("""
                CREATE INDEX IF NOT EXISTS idx_coin_transactions_guild_type ON coin_transactions(guild_id, transaction_type);
            """)

            self.logger.info("‚úÖ ÏΩîÏù∏ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏îÏù¥ Ï§ÄÎπÑÎêòÏóàÏäµÎãàÎã§.")
        except Exception as e:
            # FIX: This is a global setup, so no specific guild_id to add to log
            self.logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Ï†ï Ïã§Ìå®: {e}")

    def check_spam_protection(self, user_id: int) -> bool:
        """Check if user is spamming commands"""
        now = datetime.now()
        if user_id in self.last_command_time:
            time_diff = (now - self.last_command_time[user_id]).total_seconds()
            if time_diff < self.cooldown_seconds:
                return False

        self.last_command_time[user_id] = now
        return True

    async def get_user_coins(self, user_id: int, guild_id: int) -> int:
        """Get user's current coin balance for specific guild"""
        try:
            row = await self.bot.pool.fetchrow(
                "SELECT coins FROM user_coins WHERE user_id = $1 AND guild_id = $2",
                user_id, guild_id
            )
            return row['coins'] if row else 0
        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error getting coins for {user_id} in guild {guild_id}: {e}", extra={'guild_id': guild_id})
            return 0

    async def add_coins(self, user_id: int, guild_id: int, amount: int, transaction_type: str = "earned",
                        description: str = ""):
        """Add coins to user account and trigger leaderboard update"""
        try:
            # Update user coins
            await self.bot.pool.execute("""
                INSERT INTO user_coins (user_id, guild_id, coins, total_earned)
                VALUES ($1, $2, $3, $3)
                ON CONFLICT (user_id, guild_id) 
                DO UPDATE SET 
                    coins = user_coins.coins + $3,
                    total_earned = user_coins.total_earned + $3
            """, user_id, guild_id, amount)

            # Log transaction
            await self.bot.pool.execute("""
                INSERT INTO coin_transactions (user_id, guild_id, amount, transaction_type, description)
                VALUES ($1, $2, $3, $4, $5)
            """, user_id, guild_id, amount, transaction_type, description)

            # Trigger real-time leaderboard update
            self.bot.loop.create_task(self.schedule_leaderboard_update(guild_id))

            # FIX: Add guild_id to log message
            self.logger.info(f"Added {amount} coins to user {user_id} in guild {guild_id}: {description}", extra={'guild_id': guild_id})
            return True
        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error adding coins to {user_id} in guild {guild_id}: {e}", extra={'guild_id': guild_id})
            return False

    async def remove_coins(self, user_id: int, guild_id: int, amount: int, transaction_type: str = "spent",
                           description: str = "") -> bool:
        """Remove coins from user account and trigger leaderboard update"""
        try:
            current_coins_str = await self.get_user_coins(user_id, guild_id)

            # Solution: Convert the string value to an integer
            try:
                current_coins = int(current_coins_str)
            except (ValueError, TypeError):
                # FIX: Add guild_id to log message
                self.logger.error(f"‚ùå '{user_id}'Ïùò ÏûîÏï°Ïù¥ Ïú†Ìö®Ìïú Ïà´ÏûêÍ∞Ä ÏïÑÎãôÎãàÎã§: {current_coins_str}", extra={'guild_id': guild_id})
                return False

            if current_coins < amount:
                return False

            # Update user coins
            await self.bot.pool.execute("""
                UPDATE user_coins 
                SET coins = coins - $3, total_spent = total_spent + $3
                WHERE user_id = $1 AND guild_id = $2
            """, user_id, guild_id, amount)

            # Log transaction
            await self.bot.pool.execute("""
                INSERT INTO coin_transactions (user_id, guild_id, amount, transaction_type, description)
                VALUES ($1, $2, $3, $4, $5)
            """, user_id, guild_id, -amount, transaction_type, description)

            # Trigger real-time leaderboard update
            self.bot.loop.create_task(self.schedule_leaderboard_update(guild_id))

            # FIX: Add guild_id to log message
            self.logger.info(f"Removed {amount} coins from user {user_id} in guild {guild_id}: {description}", extra={'guild_id': guild_id})
            return True
        except Exception as e:
            # FIX: Add guild_id to log message
            self.logger.error(f"Error removing coins from {user_id} in guild {guild_id}: {e}", extra={'guild_id': guild_id})
            return False

    # Keep the original scheduled task as a backup/maintenance function
    @tasks.loop(hours=1)  # Reduced frequency since we have real-time updates
    async def maintenance_leaderboard_update(self):
        """Maintenance update every hour to ensure consistency for all guilds"""
        try:
            all_configs = config.get_all_server_configs()
            for guild_id_str, guild_config in all_configs.items():
                if guild_config.get('features', {}).get('casino_games'):
                    guild_id = int(guild_id_str)

                    # Get leaderboard channel for this guild
                    leaderboard_channel_id = config.get_channel_id(guild_id, 'leaderboard_channel')
                    if not leaderboard_channel_id:
                        continue

                    # Check if channel exists before proceeding
                    channel = self.bot.get_channel(leaderboard_channel_id)
                    if not channel:
                        # FIX: Add guild_id to log message
                        self.logger.warning(f"Maintenance task: Leaderboard channel {leaderboard_channel_id} not found for guild {guild_id}.", extra={'guild_id': guild_id})
                        continue

                    # Force update to ensure consistency
                    if guild_id in self.last_leaderboard_cache:
                        del self.last_leaderboard_cache[guild_id]
                    await self.update_leaderboard_now(guild_id)

                    # Also check if claim message needs maintenance
                    guild_str = str(guild_id)
                    if guild_str in self.guild_claim_data:
                        try:
                            message_id = self.guild_claim_data[guild_str]
                            message = await channel.fetch_message(message_id)
                            if not message.components:  # Re-add view if missing
                                await message.edit(view=CoinsView(self.bot))
                        except discord.NotFound:
                            # Recreate claim message if missing
                            embed = discord.Embed(
                                title="üí∞ ÏùºÏùº ÏΩîÏù∏",
                                description="Îß§Ïùº ÏûêÏ†ï(EST)Ïóê Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§.\nÏïÑÎûò Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ ÏùºÏùº ÏΩîÏù∏ÏùÑ Î∞õÏúºÏÑ∏Ïöî!",
                                color=discord.Color.green()
                            )
                            message = await channel.send(embed=embed, view=CoinsView(self.bot))
                            self.guild_claim_data[guild_str] = message.id
                            await self.save_message_ids()
                            # FIX: Add guild_id to log message
                            self.logger.info(f"Recreated missing claim message for guild {guild_id}", extra={'guild_id': guild_id})
                        except discord.HTTPException as e:
                            # FIX: Add guild_id to log message
                            self.logger.error(f"HTTP error during claim message maintenance for guild {guild_id}: {e}", extra={'guild_id': guild_id})

        except Exception as e:
            # FIX: This is a general maintenance task, no specific guild_id for this particular error
            self.logger.error(f"Error in maintenance leaderboard update: {e}")

    @app_commands.command(name="ÏΩîÏù∏", description="ÌòÑÏû¨ ÏΩîÏù∏ ÏûîÏï°ÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§.")
    async def check_coins(self, interaction: discord.Interaction, user: discord.Member = None):
        # Check if casino games are enabled
        if not config.is_feature_enabled(interaction.guild.id, 'casino_games'):
            await interaction.response.send_message(
                "‚ùå Ïù¥ ÏÑúÎ≤ÑÏóêÏÑúÎäî ÏΩîÏù∏ ÏãúÏä§ÌÖúÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.",
                ephemeral=True
            )
            return

        if not self.check_spam_protection(interaction.user.id):
            await interaction.response.send_message("‚è≥ Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî!", ephemeral=True)
            return

        await interaction.response.defer(ephemeral=True)

        target_user = user or interaction.user
        guild_id = interaction.guild.id
        coins = await self.get_user_coins(target_user.id, guild_id)

        try:
            # Get additional stats
            stats_query = """
                SELECT total_earned, total_spent, last_claim_date
                FROM user_coins WHERE user_id = $1 AND guild_id = $2
            """
            stats = await self.bot.pool.fetchrow(stats_query, target_user.id, guild_id)

            embed = discord.Embed(
                title=f"üí∞ {target_user.display_name}ÎãòÏùò ÏΩîÏù∏ Ï†ïÎ≥¥",
                color=discord.Color.gold(),
                timestamp=datetime.now(timezone.utc)
            )

            embed.add_field(name="ÌòÑÏû¨ ÏûîÏï°", value=f"{coins:,} ÏΩîÏù∏", inline=True)

            if stats:
                embed.add_field(name="Ï¥ù ÌöçÎìù", value=f"{stats['total_earned'] or 0:,} ÏΩîÏù∏", inline=True)
                embed.add_field(name="Ï¥ù ÏÇ¨Ïö©", value=f"{stats['total_spent'] or 0:,} ÏΩîÏù∏", inline=True)

                if stats['last_claim_date']:
                    # Ensure last_claim_date is timezone-aware for accurate formatting
                    last_claim_date_aware = stats['last_claim_date']
                    if last_claim_date_aware.tzinfo is None:
                        # Assume EST if naive, as per other parts of the cog
                        eastern = pytz.timezone('America/New_York')
                        last_claim_date_aware = eastern.localize(last_claim_date_aware)
                    else:
                        last_claim_date_aware = last_claim_date_aware.astimezone(pytz.utc) # Ensure consistent timezone before converting

                    # Format to display in EST
                    last_claim_formatted = last_claim_date_aware.astimezone(pytz.timezone('America/New_York')).strftime("%Y-%m-%d %H:%M EST")
                    embed.add_field(name="ÎßàÏßÄÎßâ ÏùºÏùº ÏΩîÏù∏", value=last_claim_formatted, inline=False)

            embed.set_thumbnail(url=target_user.display_avatar.url)

            await interaction.followup.send(embed=embed, ephemeral=True)

        except Exception as e:
            await interaction.followup.send(f"‚ùå Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {e}", ephemeral=True)
            # FIX: Add guild_id to log message
            self.logger.error(f"Error in check_coins for user {target_user.id} in guild {guild_id}: {e}", extra={'guild_id': guild_id})

    @app_commands.command(name="ÏΩîÏù∏Ï£ºÍ∏∞", description="Îã§Î•∏ ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏΩîÏù∏ÏùÑ Ï†ÑÏÜ°Ìï©ÎãàÎã§.")
    @app_commands.describe(
        user="ÏΩîÏù∏ÏùÑ Î∞õÏùÑ ÏÇ¨Ïö©Ïûê",
        amount="Ï†ÑÏÜ°Ìï† ÏΩîÏù∏ ÏàòÎüâ"
    )
    async def give_coins(self, interaction: discord.Interaction, user: discord.Member, amount: int):
        guild_id = interaction.guild.id

        # Check if casino games are enabled
        if not config.is_feature_enabled(guild_id, 'casino_games'):
            await interaction.response.send_message(
                "‚ùå Ïù¥ ÏÑúÎ≤ÑÏóêÏÑúÎäî ÏΩîÏù∏ ÏãúÏä§ÌÖúÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.",
                ephemeral=True
            )
            return

        if not self.check_spam_protection(interaction.user.id):
            await interaction.response.send_message("‚è≥ Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî!", ephemeral=True)
            return

        if interaction.user == user:
            await interaction.response.send_message("‚ùå ÏûêÍ∏∞ ÏûêÏã†ÏóêÍ≤å ÏΩîÏù∏ÏùÑ Ï§Ñ Ïàò ÏóÜÏäµÎãàÎã§.", ephemeral=True)
            return

        if amount <= 0:
            await interaction.response.send_message("‚ùå ÏΩîÏù∏ ÏàòÎüâÏùÄ 0Î≥¥Îã§ Ïª§Ïïº Ìï©ÎãàÎã§.", ephemeral=True)
            return

        # Check if sender has enough coins
        sender_coins = await self.get_user_coins(interaction.user.id, guild_id)
        if sender_coins < amount:
            await interaction.response.send_message(f"‚ùå ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§. ÌòÑÏû¨ ÏûîÏï°: {sender_coins:,} ÏΩîÏù∏", ephemeral=True)
            return

        # Attempt to remove coins from sender
        removed = await self.remove_coins(interaction.user.id, guild_id, amount, "given", f"Given to {user.display_name}")
        if not removed:
            await interaction.response.send_message("‚ùå ÏΩîÏù∏ Ï†ÑÏÜ° Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.", ephemeral=True)
            # FIX: Add guild_id to log message
            self.logger.error(f"Failed to remove coins from sender {interaction.user.id} for give_coins command in guild {guild_id}", extra={'guild_id': guild_id})
            return

        # Attempt to add coins to receiver
        added = await self.add_coins(user.id, guild_id, amount, "received", f"Received from {interaction.user.display_name}")
        if not added:
            # If adding coins fails, reverse the sender's deduction
            await self.add_coins(interaction.user.id, guild_id, amount, "refund", f"Refund for failed give to {user.display_name}")
            await interaction.response.send_message("‚ùå ÏΩîÏù∏ Ï†ÑÏÜ° Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÏûîÏï°Ïù¥ Î≥µÍµ¨ÎêòÏóàÏäµÎãàÎã§.", ephemeral=True)
            # FIX: Add guild_id to log message
            self.logger.error(f"Failed to add coins to receiver {user.id} for give_coins command in guild {guild_id}, attempted refund.", extra={'guild_id': guild_id})
            return

        # Success
        await interaction.response.send_message(f"‚úÖ {user.mention}ÎãòÍªò {amount:,} ÏΩîÏù∏ÏùÑ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†ÑÏÜ°ÌñàÏäµÎãàÎã§!")
        # FIX: Add guild_id to log message
        self.logger.info(f"User {interaction.user.id} gave {amount} coins to {user.id} in guild {guild_id}", extra={'guild_id': guild_id})

    @app_commands.command(name="ÏΩîÏù∏Í±∞ÎûòÎÇ¥Ïó≠", description="ÏÇ¨Ïö©ÏûêÏùò ÏΩîÏù∏ Í±∞Îûò ÎÇ¥Ïó≠ÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§.")
    async def view_transactions(self, interaction: discord.Interaction, user: discord.Member = None):
        guild_id = interaction.guild.id

        # Check if casino games are enabled
        if not config.is_feature_enabled(guild_id, 'casino_games'):
            await interaction.response.send_message(
                "‚ùå Ïù¥ ÏÑúÎ≤ÑÏóêÏÑúÎäî ÏΩîÏù∏ ÏãúÏä§ÌÖúÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.",
                ephemeral=True
            )
            return

        if not self.check_spam_protection(interaction.user.id):
            await interaction.response.send_message("‚è≥ Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî!", ephemeral=True)
            return

        await interaction.response.defer(ephemeral=True)

        target_user = user or interaction.user

        try:
            query = """
                SELECT amount, transaction_type, description, created_at 
                FROM coin_transactions 
                WHERE user_id = $1 AND guild_id = $2 
                ORDER BY created_at DESC 
                LIMIT 20
            """
            transactions = await self.bot.pool.fetch(query, target_user.id, guild_id)

            if not transactions:
                await interaction.followup.send("üìú Ìï¥Îãπ ÏÇ¨Ïö©ÏûêÏùò ÏΩîÏù∏ Í±∞Îûò ÎÇ¥Ïó≠Ïù¥ ÏóÜÏäµÎãàÎã§.", ephemeral=True)
                return

            embed = discord.Embed(
                title=f"üìú {target_user.display_name}ÎãòÏùò ÏΩîÏù∏ Í±∞Îûò ÎÇ¥Ïó≠",
                color=discord.Color.blue(),
                timestamp=datetime.now(timezone.utc)
            )

            transaction_details = []
            for tx in transactions:
                created_at_est = tx['created_at'].astimezone(pytz.timezone('America/New_York'))
                date_str = created_at_est.strftime("%Y-%m-%d %H:%M:%S EST")
                transaction_details.append(
                    f"**[{date_str}]**\n"
                    f"  Ïú†Ìòï: `{tx['transaction_type']}`\n"
                    f"  Í∏àÏï°: `{tx['amount']:,} ÏΩîÏù∏`\n"
                    f"  ÏÑ§Î™Ö: {tx['description'] or 'N/A'}\n"
                )

            embed.description = "\n".join(transaction_details)
            embed.set_footer(text=f"ÏµúÏã† 20Í±¥Ïùò Í±∞Îûò ÎÇ¥Ïó≠")

            await interaction.followup.send(embed=embed, ephemeral=True)

        except Exception as e:
            await interaction.followup.send(f"‚ùå Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {e}", ephemeral=True)
            # FIX: Add guild_id to log message
            self.logger.error(f"Error in view_transactions for user {target_user.id} in guild {guild_id}: {e}", extra={'guild_id': guild_id})

    @app_commands.command(name="ÏΩîÏù∏ÏÑ§Ï†ï", description="ÏÑúÎ≤ÑÏùò ÏΩîÏù∏ Í¥ÄÎ†® ÏÑ§Ï†ïÏùÑ Î≥ÄÍ≤ΩÌï©ÎãàÎã§. (Í¥ÄÎ¶¨Ïûê Ï†ÑÏö©)")
    @app_commands.describe(
        feature_enabled="Ïπ¥ÏßÄÎÖ∏ Í≤åÏûÑ Í∏∞Îä• ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî",
        starting_coins="ÏùºÏùº ÏΩîÏù∏ ÏßÄÍ∏â Ïãú Í∏∞Î≥∏ ÏΩîÏù∏ ÏàòÎüâ",
        leaderboard_channel="Î¶¨ÎçîÎ≥¥ÎìúÍ∞Ä ÌëúÏãúÎê† Ï±ÑÎÑê",
        admin_role="ÏΩîÏù∏ Í¥ÄÎ†® Í¥ÄÎ¶¨Ïûê Í∂åÌïúÏùÑ Í∞ÄÏßà Ïó≠Ìï†",
        staff_role="ÏΩîÏù∏ Í¥ÄÎ†® Ïä§ÌÉúÌîÑ Í∂åÌïúÏùÑ Í∞ÄÏßà Ïó≠Ìï†"
    )
    @app_commands.default_permissions(administrator=True)
    async def configure_coins(self, interaction: discord.Interaction,
                              feature_enabled: Optional[bool] = None,
                              starting_coins: Optional[int] = None,
                              leaderboard_channel: Optional[discord.TextChannel] = None,
                              admin_role: Optional[discord.Role] = None,
                              staff_role: Optional[discord.Role] = None):

        guild_id = interaction.guild.id
        await interaction.response.defer(ephemeral=True)

        # Get current settings
        current_config = config.get_server_config(guild_id)
        features = current_config.get('features', {})
        channels = current_config.get('channels', {})
        roles = current_config.get('roles', {})

        updated = False

        # Update feature setting
        if feature_enabled is not None:
            features['casino_games'] = feature_enabled
            updated = True
            # FIX: Add guild_id to log message
            self.logger.info(f"Casino games feature {'enabled' if feature_enabled else 'disabled'} for guild {guild_id}", extra={'guild_id': guild_id})

        # Update starting coins
        if starting_coins is not None:
            if starting_coins < 0:
                await interaction.followup.send("‚ùå ÏãúÏûë ÏΩîÏù∏ ÏàòÎüâÏùÄ 0 Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.")
                return
            current_config['settings'] = current_config.get('settings', {})
            current_config['settings']['starting_coins'] = starting_coins
            updated = True
            # FIX: Add guild_id to log message
            self.logger.info(f"Starting coins set to {starting_coins} for guild {guild_id}", extra={'guild_id': guild_id})

        # Update leaderboard channel
        if leaderboard_channel is not None:
            channels['leaderboard_channel'] = {'id': leaderboard_channel.id, 'name': leaderboard_channel.name}
            updated = True
            # FIX: Add guild_id to log message
            self.logger.info(f"Leaderboard channel set to #{leaderboard_channel.name} ({leaderboard_channel.id}) for guild {guild_id}", extra={'guild_id': guild_id})

        # Update admin role
        if admin_role is not None:
            roles['admin_role'] = {'id': admin_role.id, 'name': admin_role.name}
            updated = True
            # FIX: Add guild_id to log message
            self.logger.info(f"Admin role set to @{admin_role.name} ({admin_role.id}) for guild {guild_id}", extra={'guild_id': guild_id})

        # Update staff role
        if staff_role is not None:
            roles['staff_role'] = {'id': staff_role.id, 'name': staff_role.name}
            updated = True
            # FIX: Add guild_id to log message
            self.logger.info(f"Staff role set to @{staff_role.name} ({staff_role.id}) for guild {guild_id}", extra={'guild_id': guild_id})

        if updated:
            current_config['features'] = features
            current_config['channels'] = channels
            current_config['roles'] = roles
            config.save_server_config(guild_id, current_config)
            await interaction.followup.send("‚úÖ ÏΩîÏù∏ ÏãúÏä§ÌÖú ÏÑ§Ï†ïÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§.")

            # If casino feature was enabled/disabled or leaderboard channel changed, re-setup
            if (feature_enabled is not None and feature_enabled) or (leaderboard_channel is not None):
                await self.setup_initial_leaderboard(guild_id)
        else:
            await interaction.followup.send("‚ÑπÔ∏è Î≥ÄÍ≤Ω ÏÇ¨Ìï≠Ïù¥ ÏóÜÏñ¥ ÏÑ§Ï†ïÏùÑ ÏóÖÎç∞Ïù¥Ìä∏ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")


async def setup(bot):
    await bot.add_cog(CoinsCog(bot))